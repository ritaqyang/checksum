Parity: 		move $t2 $a0 #save pointer to text buffer 
			li $t1 0 #parity byte 
			li $t0 1 #bit position counter 
			

			
BitPositionLoop: 	li $t3 1 #mask  00000001
			li $t6 0 #parity for current bit 
CharacterLoop:		lb $t4 0($t2) #load char from text buffer 
			beqz $t4 BitDone #end of text buffer char for this bit position counting 
			
			and $t5 $t4 $t3 #check if current bit is 1
			beqz $t5 MoveNextChar #is 1 then $t5 is 1, zero then move to next char 
			addi $t6 $t6 1 #add 1 for this bit position 

MoveNextChar:		addi $t2 $t2 1 #go to next char 
			j CharacterLoop

BitDone:		andi $t6 $t6 1 #see if total count for this position is odd or even 
			move $a2 $t0 	#load bit position count in a2 prior to shifting 
			move $a1 $t6  #load parity for position
			jal ShiftLeft 		
			or $t1 $t1 $v0 #set in result byte 
			addi $t0 $t0 1 #move to next bit position 
			
			beq $t0 8 AllPositionDone #if we did 8 bits already 
			j BitPositionLoop #otherwise go back to top 


AllPositionDone: 	sb $t1 ($t2) #store to buffer 
			move $v0 $t1 
			jr $ra
	

ShiftLeft: 	move $t0 $a2
		move $v0 $a1

ShiftLoop:
    beqz $t0, ShiftEnd # Exit the loop if $t0 is 0
    sll $v0, $v0, 1    # Left-shift by 1 bit
    addi $t0, $t0, -1  # Decrement $t0
    j ShiftLoop

ShiftEnd:
   jr $ra
